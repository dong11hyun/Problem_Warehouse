## 확장(3번)

- 비정규화 전략은 **쓰기 경로의 복잡성**을 증가시키고 데이터 정합성을 해칠 새로운 위험을 내포합니다. 
- 새로운 상태 변경이 shipment_updates 테이블에 삽입될 때마다, 
- shipments 테이블에 비정규화된 current_status 와 같은 컬럼의 값을 어떻게 일관성 있게 유지할 것인지
--- 
#### Project: Data Consistency Strategies in Denormalized Architecture

(비정규화 환경에서의 데이터 정합성 유지 전략 비교)
1. 프로젝트 목표 (Objective)

    비정규화된 shipments 테이블의 current_status 컬럼을 업데이트할 때 발생하는 **쓰기 지연(Write Latency)**과 데이터 정합성(Data Consistency) 간의 상관관계를 3가지 아키텍처 패턴으로 구현하여 정량적으로 비교 분석한다.

2. 시뮬레이션 환경 (Environment)

    Data Source: 기존 Faker 라이브러리 활용 (새로운 랜덤 데이터 생성)

    Infrastructure: 로컬 Python + MySQL (별도의 RabbitMQ 설치 없이 Python Queue와 Threading으로 비동기 아키텍처 모방)

3. 구현할 세 가지 아키텍처 (The 3 Strategies)
Strategy A: 동기적 애플리케이션 트랜잭션 (Strong Consistency)

    개념: 애플리케이션(Python) 레벨에서 BEGIN Transaction을 걸고, INSERT log와 UPDATE shipment를 하나의 원자적 단위(Atomic)로 묶음.

    예상 결과: 데이터는 완벽하게 일치하지만, 쓰기 속도가 가장 느릴 것임.

    구현 포인트: pymysql의 conn.begin(), conn.commit(), conn.rollback() 활용.

Strategy B: 데이터베이스 트리거 (DB-Level Consistency)

    개념: 애플리케이션은 로그만 INSERT 하고 빠짐. DB 내부에 심어둔 AFTER INSERT TRIGGER가 자동으로 shipments 테이블을 갱신함.

    예상 결과: 애플리케이션 코드는 단순해지나, DB CPU 부하가 증가하고 디버깅이 어려움.

    구현 포인트: MySQL에 CREATE TRIGGER SQL 실행.

Strategy C: 비동기 메시지 큐 (Eventual Consistency)

    개념: 애플리케이션은 로그 INSERT 후, 메모리 큐에 이벤트를 던지고 즉시 리턴(Fire & Forget). 별도의 워커 스레드(Worker Thread)가 뒤늦게 큐에서 꺼내어 UPDATE 수행.

    예상 결과: 쓰기 속도가 압도적으로 빠르지만, 아주 짧은 순간(ms) 데이터 불일치 발생.

    구현 포인트: Python queue.Queue와 threading 모듈로 생산자-소비자 패턴(Producer-Consumer Pattern) 구현.

4. 벤치마킹 시나리오 (Benchmark Plan)

각 전략별로 화물 상태 업데이트 요청 1,000건을 연속으로 수행하며 다음 지표를 측정합니다.

    평균 쓰기 지연 시간 (Avg Write Latency): 사용자가 "업데이트 버튼"을 누르고 "완료" 응답을 받을 때까지 걸린 시간.

    데이터 일관성 검증 (Consistency Check):

        비동기 방식의 경우, 메인 작업이 끝난 직후 shipments 테이블 조회 시 값이 갱신되어 있는가? 아니면 아직 옛날 값인가? (Lag 측정)

5. 실행 로드맵 (Execution Steps)

시니어 엔지니어로서 다음과 같은 단계로 진행하기를 권장합니다.

    [Step 1] 환경 리셋: 기존 데이터를 유지하되, 트리거 테스트를 위해 깨끗한 상태 준비.

    [Step 2] 통합 테스트 스크립트 작성 (consistency_test.py): 하나의 파이썬 파일 안에서 3가지 모드를 스위칭하며 테스트할 수 있게 구조화.

    [Step 3] 실행 및 리포트: 각 전략을 실행하고 나오는 수치(Time, Consistency) 기록.

    [Step 4] README 업데이트: "읽기 성능은 잡았으나 쓰기 비용이 발생했고, 이를 비동기 큐로 해결했다"는 식의 스토리 완성.