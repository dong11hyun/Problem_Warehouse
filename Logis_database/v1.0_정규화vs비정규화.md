#### 대용량 데이터베이스 정규화 vs 비정규화 성능 최적화
##### <문제상황 가정>
- Logis-Flow는 화주와 운송사에게 실시간 화물 위치와 상태 정보를 제공하는 SaaS 솔루션 서비스 
- 데이터 무결성을 위해 **제3정규형**을 준수하여 설계
- 데이터가 급증함에 따라 대시보드 로딩 속도가 심각하게 저하되는 병목 현상이 발생

##### 성능 및 리소스 모니터링 시작 (Process: mysqld)
```
정규화 (Slow)
--------------------------------------------------
⏱️  소요 시간 : 63.7656 초
🔥  평균 CPU  : 96.1 %
-데이터 정합성 중복 없음
-관리 포인트	로그만 적재하면 끝
--------------------------------------------------

정규화 + 인덱스 사용 (Normal)
--------------------------------------------------
⏱️  소요 시간 : 0.1329 초
🔥  평균 CPU  : 49.9 %
-데이터 정합성 중복 없음
-관리 포인트	로그만 적재하면 끝
--------------------------------------------------

[비정규화 (Denormalized)] 
--------------------------------------------------
⏱️  소요 시간 : 0.0045 초
🔥  평균 CPU  : 1.6 %
-데이터 정합성 위험 (중복 존재)
-상태 변경 시 두 테이블 동시 업데이트 필수
--------------------------------------------------
```
##### 핵심 병목 (Bottleneck)

- 화물 1건당 수십 건의 상태 변경 로그가 존재. 
- 특정 화물의 '가장 최신 로그' 1건을 찾기 위해 서브쿼리 내에서 ORDER BY timestamp DESC LIMIT 1 연산이 매 행(Row)마다 발생.

##### <Tech_Stack>

    Language: Python 3.9
    Database: MySQL 8.0
    Tools: MySQL Workbench, Faker Library
    Data 
        - Shipments: 50,000 Rows (화물)
        - Shipment_Updates: 500,000 Rows (상태 변경 로그)


#### 성능 비교 및 해결 과정 
**정규화 모델 (Before)**
- 가장 최신의 상태를 가져오기 위해, 매 행마다 로그 테이블을 풀 스캔(Full Scan)

**인덱스 최적화 (solution1)**
- shipment_updates(shipment_id) 인덱스를 정상적으로 활용

**비정규화 적용 (Solution)**
- 읽기(Read) 성능을 위해 쓰기(Write) 비용을 희생하는 비정규화를 채택 
- Shipments 테이블에 중복 데이터(current_status, last_updated_at)를 저장할 컬럼을 추가
- 데이터 마이그레이션을 수행

#### 결론 

이번 프로젝트를 통해 성능 최적화의 단계 정립
- **인덱스는 1차 방어선** : 적절한 인덱싱만으로도 63초를 0.13초로 줄일 수 있습니다. 트래픽이 적당하다면 여기서 멈추는 것이 유지보수 측면에서 유리합니다. **하지만 cpu 사용량이 은근히 높다.**

- 대시보드와 같이 조회(Read) 빈도가 압도적으로 높고, 동시성 처리가 중요한 기능에서는 데이터 중복을 허용하더라도 조회 비용을 '0'에 수렴하게 만드는 **비정규화가 답이 될 수도 있음.**

- **성능을 얻고** 데이터 정합성 유지의 책임이 DB 엔진에서 개발자로 넘어옴. 이를 위해 **트랜잭션(Transaction) 관리와 데이터 불일치 방지** 로직이 더욱 중요해짐.




